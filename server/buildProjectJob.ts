import {dnsLookup} from '../imports/stages/dnsLookup';
import {getBuildStages} from '../imports/stages/getBuildStages';
import {getEnv} from '../imports/stages/getEnv';
import {Projects, BuildSessions} from '../lib/collections';

export var BuildProjectJob = {};

// Generated by CoffeeScript 1.12.7
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  this.BuildProjectJob = (function(superClass) {
    extend(BuildProjectJob, superClass);

    function BuildProjectJob() {
      return BuildProjectJob.__super__.constructor.apply(this, arguments);
    }

    BuildProjectJob.prototype.handleJob = function() {
      var author, buildDir, deployment, err, ex, exception, fr, gitInfo, hash, i, len, msg, org, orgAndRepo, out, previous, proj, ref, repo, s, session, stageDir, stages, subject, targetUrl, url;
      deployment = this.params.deployment;
      proj = Projects.findOne(deployment.projectId);
      session = BuildSessions.findOne({
        deploymentId: deployment._id
      }, {
        sort: {
          timestamp: -1
        }
      });
      console.log('*** building project ' + proj.name + ' for ' + deployment.targetHost + ' ***');
      BuildSessions.update(session._id, {
        $set: {
          status: 'Building',
          message: 'Fetching...',
          timestamp: Date.now()
        }
      });
      fr = FileRegistry.getFileRoot();
      targetUrl = Npm.require('url').parse(deployment.targetHost);
      buildDir = fr + 'sandbox/build';
      console.log(targetUrl.hostname);
      stageDir = fr + 'sandbox/stage/' + dnsLookup(targetUrl.hostname);
      orgAndRepo = proj.gitUrl.match(/([a-zA-Z0-9-_.]+)\/([a-zA-Z0-9-_.]+)$/);
      org = orgAndRepo[1];
      repo = orgAndRepo[2].replace('.git', '');
      url = "https://" + Meteor.settings.ghApiToken + ":x-oauth-basic@github.com/" + org + "/" + repo;
      this.params.cmd = "mkdir -p " + buildDir + "\ncd " + buildDir + "\nif [[ -e \"" + repo + "/\" ]]\nthen\n  cd " + repo + "\n  git reset --hard\n  git checkout --\n  git clean -dff\n  git fetch\nelse\n  git clone --depth=1 " + url + "\n  cd " + repo + "\nfi\n\ngit fetch origin '+refs/heads/*:refs/remotes/origin/*'\n#git checkout `git log --all --format=\"%H\" -1`\ngit checkout origin/" + deployment.branch + "\n#git pull\ngit log --format=\"%H\" -1\ngit log --format=\"%s\" -1\ngit log --format=\"%cn\" -1";
      ex = BuildProjectJob.__super__.handleJob.call(this);
      out = ex.stdout;
      console.log(out);
      gitInfo = out.trim().split('\n');
      if (gitInfo.length >= 3) {
        gitInfo = gitInfo.slice(gitInfo.length - 3, gitInfo.length + 1);
      } else {
        gitInfo = [null, null, null];
      }
      hash = gitInfo[0];
      subject = gitInfo[1];
      author = gitInfo[2];
      console.log('gitInfo ', gitInfo);
      if (hash == null) {
        hash = 'unknown';
      }
      if (author == null) {
        author = 'unknown';
      }
      if (subject == null) {
        subject = 'No commit message.';
      }
      console.log("hash: " + hash);
      BuildSessions.update(session._id, {
        $set: {
          message: 'Cloned successfully',
          timestamp: Date.now(),
          git: {
            commitHash: hash,
            committerName: author,
            commitMessage: subject
          }
        },
        $push: {
          stages: {
            name: 'Fetch',
            stdout: out
          }
        }
      });
      if (deployment.settings != null) {
        Npm.require('fs').writeFileSync(buildDir + ("/" + repo + "/settings.json"), deployment.settings);
      }
      if (!this.params.forceRebuild) {
        previous = BuildSessions.find({
          deploymentId: this.params.deployment._id
        }, {
          sort: {
            timestamp: -1
          },
          limit: 2
        }).fetch();
        if (previous.length >= 2 && hash === ((ref = previous.pop().git) != null ? ref.commitHash : void 0)) {
          console.log("No changes since last check");
          BuildSessions.remove({
            _id: session._id
          });
          return;
        }
      }
      
      stages = getBuildStages(fr, deployment, proj, repo, buildDir, stageDir);
      
      try {
        this.params.env = getEnv(fr, deployment, proj, repo, buildDir, stageDir);
      } catch (error) {
        err = error;
        BuildSessions.update(session._id, {
          $set: {
            status: 'Unsupported',
            message: err,
            timestamp: Date.now()
          }
        });
        return;
      }
      if (!stages) {
        BuildSessions.update(session._id, {
          $set: {
            status: 'Unsupported',
            message: 'Not a supported type of repository',
            timestamp: Date.now()
          }
        });
        return;
      }
      for (i = 0, len = stages.length; i < len; i++) {
        s = stages[i];
        if (s.cmd != null) {
          this.params.cmd = "set -ex\ncd " + fr + "/sandbox/build/" + repo + "\n" + s.cmd;
        }
        BuildSessions.update(session._id, {
          $set: {
            message: s.name
          }
        });
        console.log("=== begin stage " + s.name + " (" + repo + ") ===");
        if (s.cmd != null) {
          ex = BuildProjectJob.__super__.handleJob.call(this);
          console.log(ex.stdout);
          if (ex.code !== 0) {
            console.log('FAILURE');
          } else {
            console.log('SUCCESS');
          }
        } else if (s.func != null) {
          try {
            s.func.call(this, fr, deployment, proj, repo, buildDir, stageDir);
            ex = {
              code: 0,
              stdout: ''
            };
          } catch (error) {
            exception = error;
            ex = {
              code: 1,
              stdout: exception.toString()
            };
          }
        }
        console.log("=== end stage " + s.name + " (" + repo + ") ===");
        BuildSessions.update(session._id, {
          $push: {
            stages: {
              name: s.name,
              stdout: ex.stdout
            }
          }
        });
        if (ex.code !== 0) {
          msg = s.errorMessage != null ? s.errorMessage(ex.stdout) : s.name + " returned exit code " + ex.code;
          check(msg, String);
          BuildSessions.update(session._id, {
            $set: {
              status: 'Fail',
              message: msg
            }
          });
          return;
        }
      }
      return BuildSessions.update(session._id, {
        $set: {
          status: 'Pass',
          message: 'All phases successful',
          timestamp: Date.now()
        }
      });
    };

    return BuildProjectJob;

  })(ExecJob);

  // Hack to export
  BuildProjectJob = this.BuildProjectJob;

}).call(this);
